<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ëª¨ë‹¥ë¶ˆ ë””íœìŠ¤</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: #111827;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      overflow: hidden;
    }
    .hud {
      display: flex;
      gap: 24px;
      margin-bottom: 16px;
      color: white;
      font-size: 18px;
    }
    .score { color: #facc15; }
    .wave { color: #60a5fa; }
    .hp-good { color: #4ade80; }
    .hp-bad { color: #ef4444; }
    #gameCanvas {
      border: 4px solid #374151;
      border-radius: 12px;
      cursor: pointer;
      touch-action: none;
    }
    .overlay {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      border-radius: 12px;
    }
    .overlay h1 { color: #f97316; font-size: 32px; margin-bottom: 16px; }
    .overlay h2 { color: white; font-size: 28px; margin-bottom: 8px; }
    .overlay p { color: #9ca3af; margin-bottom: 8px; font-size: 16px; }
    .overlay .final-score { color: #facc15; font-size: 24px; margin-bottom: 16px; }
    .btn {
      padding: 16px 32px;
      background: #f97316;
      color: white;
      border: none;
      border-radius: 12px;
      font-size: 20px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 16px;
    }
    .btn:hover { background: #ea580c; }
    .game-container { position: relative; }
    .info { color: #6b7280; font-size: 14px; margin-top: 16px; text-align: center; }
  </style>
</head>
<body>
  <div class="hud">
    <span>ì ìˆ˜: <strong class="score" id="scoreText">0</strong></span>
    <span>ì›¨ì´ë¸Œ: <strong class="wave" id="waveText">1</strong>/5</span>
    <span>ëª¨ë‹¥ë¶ˆ: <strong id="hpText" class="hp-good">â¤ï¸â¤ï¸â¤ï¸â¤ï¸â¤ï¸</strong></span>
  </div>
  
  <div class="game-container">
    <canvas id="gameCanvas" width="400" height="400"></canvas>
    
    <div class="overlay" id="startScreen">
      <h1>ğŸ”¥ ëª¨ë‹¥ë¶ˆ ë””íœìŠ¤</h1>
      <p>í„°ì¹˜/í´ë¦­ìœ¼ë¡œ ì´ë™</p>
      <p>ê°€ê¹Œìš´ ì¢€ë¹„ ìë™ ê³µê²©</p>
      <button class="btn" onclick="startGame()">ê²Œì„ ì‹œì‘</button>
    </div>
    
    <div class="overlay" id="gameOverScreen" style="display:none;">
      <h2 id="resultTitle">ğŸ’€ ê²Œì„ ì˜¤ë²„</h2>
      <p class="final-score">ìµœì¢… ì ìˆ˜: <span id="finalScore">0</span></p>
      <button class="btn" onclick="startGame()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
  </div>
  
  <div class="info">
    <p>ğŸ”µ í”Œë ˆì´ì–´ | ğŸŸ¢ ì¢€ë¹„ | ğŸŸ  ëª¨ë‹¥ë¶ˆ</p>
  </div>

<script>
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let game = {
  player: { x: 200, y: 250, size: 20, speed: 4, attackRange: 80, cooldown: 0 },
  bonfire: { x: 200, y: 200, hp: 10, maxHp: 10, size: 30 },
  zombies: [],
  bullets: [],
  particles: [],
  score: 0,
  wave: 1,
  killed: 0,
  perWave: 5,
  running: false,
  target: null,
  spawnTimer: 0,
  waveDelay: 0
};

function startGame() {
  game = {
    player: { x: 200, y: 250, size: 20, speed: 4, attackRange: 80, cooldown: 0 },
    bonfire: { x: 200, y: 200, hp: 10, maxHp: 10, size: 30 },
    zombies: [],
    bullets: [],
    particles: [],
    score: 0,
    wave: 1,
    killed: 0,
    perWave: 5,
    running: true,
    target: null,
    spawnTimer: 0,
    waveDelay: 60
  };
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('gameOverScreen').style.display = 'none';
  updateHUD();
  requestAnimationFrame(loop);
}

function spawnZombie() {
  const side = Math.floor(Math.random() * 4);
  let x, y;
  if (side === 0) { x = Math.random() * 400; y = -20; }
  else if (side === 1) { x = 420; y = Math.random() * 400; }
  else if (side === 2) { x = Math.random() * 400; y = 420; }
  else { x = -20; y = Math.random() * 400; }
  
  game.zombies.push({
    x, y, size: 18,
    speed: 0.8 + game.wave * 0.15,
    hp: 2 + Math.floor(game.wave / 2)
  });
}

function updateHUD() {
  document.getElementById('scoreText').textContent = game.score;
  document.getElementById('waveText').textContent = game.wave;
  const hpEl = document.getElementById('hpText');
  const hearts = Math.max(0, Math.ceil(game.bonfire.hp / 2));
  hpEl.textContent = 'â¤ï¸'.repeat(hearts);
  hpEl.className = game.bonfire.hp > 3 ? 'hp-good' : 'hp-bad';
}

function endGame(won) {
  game.running = false;
  if (won) game.score += 500;
  document.getElementById('resultTitle').textContent = won ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ’€ ê²Œì„ ì˜¤ë²„';
  document.getElementById('finalScore').textContent = game.score;
  document.getElementById('gameOverScreen').style.display = 'flex';
}

function handleInput(e) {
  if (!game.running) return;
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const scaleX = 400 / rect.width;
  const scaleY = 400 / rect.height;
  const clientX = e.touches ? e.touches[0].clientX : e.clientX;
  const clientY = e.touches ? e.touches[0].clientY : e.clientY;
  game.target = {
    x: (clientX - rect.left) * scaleX,
    y: (clientY - rect.top) * scaleY
  };
}

canvas.addEventListener('click', handleInput);
canvas.addEventListener('mousemove', e => { if (e.buttons === 1) handleInput(e); });
canvas.addEventListener('touchstart', handleInput, { passive: false });
canvas.addEventListener('touchmove', handleInput, { passive: false });

function loop() {
  if (!game.running) return;
  
  // Clear
  ctx.fillStyle = '#1a1a2e';
  ctx.fillRect(0, 0, 400, 400);
  
  // Wave delay
  if (game.waveDelay > 0) {
    game.waveDelay--;
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 24px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(`ì›¨ì´ë¸Œ ${game.wave} ì‹œì‘!`, 200, 200);
    requestAnimationFrame(loop);
    return;
  }
  
  // Spawn
  game.spawnTimer++;
  const rate = Math.max(60, 120 - game.wave * 15);
  if (game.spawnTimer >= rate && game.zombies.length < game.perWave + game.wave * 2) {
    spawnZombie();
    game.spawnTimer = 0;
  }
  
  // Player move
  if (game.target) {
    const dx = game.target.x - game.player.x;
    const dy = game.target.y - game.player.y;
    const dist = Math.sqrt(dx * dx + dy * dy);
    if (dist > 5) {
      game.player.x += (dx / dist) * game.player.speed;
      game.player.y += (dy / dist) * game.player.speed;
    }
    game.player.x = Math.max(20, Math.min(380, game.player.x));
    game.player.y = Math.max(20, Math.min(380, game.player.y));
  }
  
  // Auto attack
  game.player.cooldown = Math.max(0, game.player.cooldown - 1);
  if (game.player.cooldown === 0 && game.zombies.length > 0) {
    let nearest = null, nearestD = Infinity;
    game.zombies.forEach(z => {
      const d = Math.hypot(z.x - game.player.x, z.y - game.player.y);
      if (d < nearestD && d < game.player.attackRange) {
        nearest = z;
        nearestD = d;
      }
    });
    if (nearest) {
      const dx = nearest.x - game.player.x;
      const dy = nearest.y - game.player.y;
      const d = Math.hypot(dx, dy);
      game.bullets.push({
        x: game.player.x, y: game.player.y,
        vx: (dx / d) * 8, vy: (dy / d) * 8, size: 5
      });
      game.player.cooldown = 20;
    }
  }
  
  // Bullets
  game.bullets = game.bullets.filter(b => {
    b.x += b.vx;
    b.y += b.vy;
    if (b.x < 0 || b.x > 400 || b.y < 0 || b.y > 400) return false;
    
    for (let i = game.zombies.length - 1; i >= 0; i--) {
      const z = game.zombies[i];
      if (Math.hypot(b.x - z.x, b.y - z.y) < z.size + b.size) {
        z.hp--;
        if (z.hp <= 0) {
          for (let p = 0; p < 5; p++) {
            game.particles.push({
              x: z.x, y: z.y,
              vx: (Math.random() - 0.5) * 4,
              vy: (Math.random() - 0.5) * 4,
              life: 30
            });
          }
          game.zombies.splice(i, 1);
          game.score += 10 * game.wave;
          game.killed++;
          updateHUD();
          
          if (game.killed >= game.perWave + (game.wave - 1) * 2) {
            game.wave++;
            game.killed = 0;
            game.waveDelay = 90;
            if (game.wave > 5) { endGame(true); return false; }
            updateHUD();
          }
        }
        return false;
      }
    }
    return true;
  });
  
  // Zombies
  game.zombies.forEach(z => {
    const dx = game.bonfire.x - z.x;
    const dy = game.bonfire.y - z.y;
    const d = Math.hypot(dx, dy);
    z.x += (dx / d) * z.speed;
    z.y += (dy / d) * z.speed;
    
    if (d < game.bonfire.size + z.size) {
      game.bonfire.hp -= 0.02;
      updateHUD();
      if (game.bonfire.hp <= 0) endGame(false);
    }
  });
  
  // Particles
  game.particles = game.particles.filter(p => {
    p.x += p.vx;
    p.y += p.vy;
    p.life--;
    return p.life > 0;
  });
  
  // Draw glow
  const grad = ctx.createRadialGradient(game.bonfire.x, game.bonfire.y, 10, game.bonfire.x, game.bonfire.y, 80);
  grad.addColorStop(0, 'rgba(255,150,50,0.3)');
  grad.addColorStop(1, 'rgba(255,150,50,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(game.bonfire.x, game.bonfire.y, 80, 0, Math.PI * 2);
  ctx.fill();
  
  // Draw bonfire
  ctx.fillStyle = '#f97316';
  ctx.beginPath();
  ctx.arc(game.bonfire.x, game.bonfire.y, game.bonfire.size, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#fbbf24';
  ctx.beginPath();
  ctx.arc(game.bonfire.x, game.bonfire.y - 5, game.bonfire.size * 0.6, 0, Math.PI * 2);
  ctx.fill();
  
  // Bonfire HP bar
  ctx.fillStyle = '#333';
  ctx.fillRect(game.bonfire.x - 25, game.bonfire.y + 40, 50, 8);
  ctx.fillStyle = game.bonfire.hp > 3 ? '#22c55e' : '#ef4444';
  ctx.fillRect(game.bonfire.x - 25, game.bonfire.y + 40, 50 * (game.bonfire.hp / game.bonfire.maxHp), 8);
  
  // Draw player
  ctx.fillStyle = '#60a5fa';
  ctx.beginPath();
  ctx.arc(game.player.x, game.player.y, game.player.size, 0, Math.PI * 2);
  ctx.fill();
  ctx.fillStyle = '#93c5fd';
  ctx.beginPath();
  ctx.arc(game.player.x - 5, game.player.y - 5, 6, 0, Math.PI * 2);
  ctx.fill();
  
  // Attack range
  ctx.strokeStyle = 'rgba(96,165,250,0.2)';
  ctx.beginPath();
  ctx.arc(game.player.x, game.player.y, game.player.attackRange, 0, Math.PI * 2);
  ctx.stroke();
  
  // Draw zombies
  game.zombies.forEach(z => {
    ctx.fillStyle = '#4ade80';
    ctx.beginPath();
    ctx.arc(z.x, z.y, z.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#166534';
    ctx.beginPath();
    ctx.arc(z.x - 5, z.y - 3, 4, 0, Math.PI * 2);
    ctx.arc(z.x + 5, z.y - 3, 4, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Draw bullets
  ctx.fillStyle = '#fbbf24';
  game.bullets.forEach(b => {
    ctx.beginPath();
    ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
    ctx.fill();
  });
  
  // Draw particles
  game.particles.forEach(p => {
    ctx.fillStyle = '#4ade80';
    ctx.globalAlpha = p.life / 30;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
    ctx.fill();
  });
  ctx.globalAlpha = 1;
  
  requestAnimationFrame(loop);
}
</script>
</body>
</html>
